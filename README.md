
# E-Commerce

## 개요

이 프로젝트는 **상품의 재고 관리**, **유저의 잔액 관리**, **선착순 쿠폰 발급**과 같은 기능을 포함하는 **이커머스** 시스템입니다. 이 시스템에서는 여러 사용자가 동시에 트랜잭션을 처리할 수 있기 때문에 **동시성 문제**가 발생할 수 있습니다. 이러한 문제를 방지하고 데이터의 일관성을 보장하기 위해, 각 시나리오에서 발생할 수 있는 동시성 이슈와 이를 해결하기 위한 동시성 제어 방식을 아래와 같이 정리합니다.



## 0. 동시성 제어 방식 비교

### 1. **비관적 락 (Pessimistic Lock)**

#### 장점
- **정확한 동시성 제어**: 락을 통해 **경쟁 상태**를 완전히 방지할 수 있습니다. 예를 들어, 상품의 재고나 쿠폰 수량을 정확히 관리할 수 있습니다.
- **ACID 특성 보장**: DB 내에서 동작하므로 트랜잭션의 일관성과 격리성을 보장합니다.
- **교착 상태 처리**: DB 엔진에서 자동으로 **교착 상태**를 처리하므로 별도의 로직이 필요 없습니다.

#### 단점
- **성능 저하**: 트랜잭션 경합이 많을 경우 **성능이 저하**될 수 있습니다. 특히 높은 동시성 요청이 발생하는 경우, 락 대기 시간이 길어집니다.
- **트랜잭션 대기 시간**: 락을 기다리는 트랜잭션이 많으면 **응답 시간이 증가**할 수 있습니다.

#### 적합한 상황
- **정확성**이 중요한 경우 (예: 재고 차감, 쿠폰 발급 수량 관리)에는 **비관적 락**이 적합합니다. 성능보다는 데이터의 일관성을 우선시해야 할 때 유용합니다.

---

### 2. **낙관적 락 (Optimistic Lock)**

#### 장점
- **성능 우수**: 락을 걸지 않으므로 **경합이 적은 경우** 성능이 뛰어나며 높은 트래픽을 처리할 수 있습니다.
- **낮은 대기 시간**: 락을 기다리는 대기 시간이 없어 시스템의 응답 속도가 빠릅니다.
- **단순성**: 락을 관리하는 별도의 오버헤드가 없어서 **간단한 로직**으로 동시성 문제를 해결할 수 있습니다.

#### 단점
- **충돌 시 롤백 및 재시도**: 경합이 발생하면 **충돌**이 발생하여 롤백 후 **재시도**가 필요합니다. 이로 인해 **성능 저하**가 발생할 수 있습니다.
- **충돌 관리 로직 필요**: 충돌 발생 시 이를 처리하기 위한 **추가적인 로직**이 필요합니다.

#### 적합한 상황
- 충돌이 드물거나 **경합이 적은 상황**(예: 잔액 관리)에서 성능과 효율성을 최적화할 수 있습니다.

---

### 3. **분산 락 (Redis 등)**

#### 장점
- **확장성**: **분산 시스템**에서 동시성 제어가 가능하며, **여러 서버 간**의 동시성 문제를 처리할 수 있습니다.
- **높은 성능**: Redis와 같은 시스템은 **빠른 성능**을 제공하여 **대량의 요청 처리**가 가능하고, 대기 시간이 적습니다.
- **분산 환경에 적합**: 여러 서버가 동시에 데이터를 수정해야 하는 경우 **효율적**입니다.

#### 단점
- **추가적인 인프라 관리**: Redis와 같은 외부 시스템을 도입해야 하므로 **추가적인 인프라 관리**가 필요합니다.
- **일관성 문제**: Redis는 **ACID 트랜잭션**을 보장하지 않기 때문에, 데이터 일관성 유지를 위한 **추가적인 로직**이 필요합니다.
- **복잡성 증가**: 분산 락을 구현하기 위한 **복잡한 코드**와 **모니터링**이 필요합니다.

#### 적합한 상황
- **분산 시스템** 환경에서 여러 서버 간에 데이터를 처리해야 할 경우, 높은 성능을 요구하는 환경에서는 Redis와 같은 분산 락이 적합합니다.

---

## 1. 상품의 재고 차감 및 복원

### 동시성 문제

상품을 구매할 때마다 **재고 차감**을 처리합니다. 하지만 여러 사용자가 동시에 같은 상품을 구매하려 할 경우, **동시 재고 차감**이 발생할 수 있습니다. 이 경우 재고가 실제보다 과도하게 차감되거나, 재고 부족 상황에서도 주문을 받을 수 있는 **경쟁 상태**(race condition)가 발생할 수 있습니다.

### 해결 방안

- **비관적 락(Pessimistic Lock)**을 사용하여 상품의 재고를 차감할 때 **하나의 트랜잭션만** 재고를 변경할 수 있도록 보장합니다.
- **`SELECT FOR UPDATE`** 쿼리를 사용하여 상품 재고를 조회할 때 락을 걸고, 다른 트랜잭션은 해당 데이터를 수정할 수 없게 합니다. 이렇게 하면 한 트랜잭션이 재고를 차감하는 동안 다른 트랜잭션은 대기하게 되어 **경쟁 상태**를 방지합니다.

#### 이유
- 상품의 재고는 **정확한 수량**을 유지해야 하므로, **ACID** 특성을 보장하는 **비관적 락** 방식으로 동시성을 제어하는 것이 적합합니다. 재고가 과도하게 차감되거나, 재고 부족 상황에서 주문을 받는 일이 없어야 하므로 강력한 동시성 제어가 필요합니다.

---

## 2. 유저의 잔액

### 동시성 문제

유저가 상품을 구매할 때마다 **잔액 차감**을 처리합니다. 여러 사용자가 동시에 구매를 하거나, 동일한 유저가 빠르게 여러 번의 구매를 진행할 경우, **잔액이 중복 차감**되는 동시성 문제가 발생할 수 있습니다.

### 해결 방안

- **낙관적 락(Optimistic Lock)**을 사용하여 잔액을 수정합니다. 각 유저 잔액 엔티티에는 **버전 정보**를 두고, 포인트를 수정할 때 버전 정보가 일치하는지 확인합니다.
- 유저가 잔액을 수정할 때마다, 버전이 일치하면 잔액을 업데이트하고, 그렇지 않으면 충돌이 발생했다고 판단하여 롤백 후 **재시도**합니다.

#### 이유
- 잔액은 동시성 충돌을 처리할 수 있도록 **낙관적 락**을 사용하는 것이 적합합니다. 유저의 잔액을 업데이트할 때 충돌을 감지하고 롤백하여 **일관성**을 유지하는 방법이 효율적입니다. **버전 관리**를 통해 **낙관적 락**이 적합하다는 판단을 내렸습니다.

---

## 3. 선착순 쿠폰 발급

### 동시성 문제

선착순으로 제공되는 쿠폰의 경우, **동시에 여러 사용자가 쿠폰을 발급**하려 할 때 **동시성 문제**가 발생할 수 있습니다. 예를 들어, 동시에 여러 명의 사용자가 쿠폰 발급을 시도할 경우, 발급 가능한 수량보다 더 많은 쿠폰이 발급되는 문제가 발생할 수 있습니다.

### 해결 방안

- **비관적 락(Pessimistic Lock)**을 사용하여 쿠폰 발급 처리를 진행합니다. 쿠폰 수량을 체크하고 발급하는 과정에서 **`SELECT FOR UPDATE`** 쿼리를 사용하여 **발급된 쿠폰 수량**을 업데이트하는 동안 다른 트랜잭션이 접근하지 못하게 락을 걸어줍니다.
- 이를 통해 **쿠폰 발급 수량 초과**를 방지하고, 정확하게 선착순으로 쿠폰을 발급할 수 있도록 보장합니다.

#### 이유
- **선착순 쿠폰 발급**은 정확한 **수량 관리**가 필수적입니다. 동시성 문제를 방지하고, 중복 발급을 막기 위해 **비관적 락**을 사용하여 재고와 동일한 방식으로 **발급 수량을 관리**합니다. 이를 통해 **경쟁 상태**를 방지하고, 항상 정확한 수량만큼 쿠폰을 발급할 수 있습니다.

---

## DB 락을 사용한 이유: Redis와 같은 분산 락을 사용하지 않은 이유

### DB 락을 선택한 이유

이 시스템에서는 **Redis와 같은 분산 락을 사용하지 않고 DB 락을 선택**했습니다. 그 이유는 아래와 같습니다:

1. **단일 시스템에서의 관리 용이성**
    - 현재 시스템은 **단일 DB 환경**에서 동작하며, **분산 시스템**으로 확장되지 않았습니다. 이 경우 **DB 락**을 사용하면 **외부 캐시 시스템**(예: Redis)을 관리할 필요 없이 **단일 데이터베이스** 내에서 모든 동시성 제어를 처리할 수 있습니다.
    - DB 락을 사용함으로써 시스템의 **복잡성을 최소화**하고, 락 관리 및 트랜잭션 관리 등을 **한 곳에서 처리**할 수 있어 관리가 용이합니다.

2. **ACID 트랜잭션 보장**
    - DB 락을 사용할 때, **ACID 트랜잭션**을 통해 데이터의 **일관성**, **격리성**을 보장할 수 있습니다. 트랜잭션 내에서 락을 걸고 처리하는 방식은 데이터베이스의 **내장된 락 관리**를 활용하여 **데이터 무결성**을 유지합니다.
    - **Redis**와 같은 분산 캐시 시스템을 사용하는 경우, **내구성** 및 **트랜잭션 지원**이 부족할 수 있기 때문에 **ACID** 트랜잭션을 보장하는 DB 락 방식이 더 적합합니다.

3. **교착 상태(Deadlock) 자동 처리**
    - DB에서 발생하는 **교착 상태**는 DB 엔진이 자동으로 감지하고 처리할 수 있습니다. **DB 락**은 기본적으로 **교착 상태**를 감지하여 트랜잭션을 **롤백**하고, 개발자가 이를 별도로 처리할 필요가 없습니다.
    - **Redis**와 같은 분산 락은 **교착 상태 처리**가 복잡하고, 교착 상태를 해결하기 위한 추가적인 로직을 구현해야 하기 때문에, 이러한 관리 부담을 줄이기 위해 DB 락을 선택했습니다.

4. **비즈니스 요구 사항에 맞는 충분한 성능**
    - 현재 시스템의 비즈니스 요구 사항에서는 **DB 락**을 사용해도 충분히 높은 **성능**을 유지할 수 있습니다. **분산 락 시스템**을 도입하기 전에, DB 락만으로 **동시성 문제**를 해결할 수 있으면 관리가 더 간편하고, 시스템의 **복잡성을 줄일 수 있습니다**.
    - 시스템이 **단일 DB 환경**에서 작동하고, 동시 요청 처리량이 상대적으로 적을 때는 **Redis와 같은 분산 락을 사용하는 것**보다 DB 락을 사용하는 것이 **효율적**일 수 있습니다.
